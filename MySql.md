## 什么是MySQL?

MySQL 是一种关系型数据库，在Java企业级开发中非常常用

## 存储引擎

**常见存储引擎：**

Myisam

InnoDB：支持自适应哈希索引

支持事务、崩溃回复、聚簇索引、支持行级锁、外键

![image-20200616160815287](/Users/ran/Library/Application Support/typora-user-images/image-20200616160815287.png)

[具体区别](https://blog.csdn.net/qq_34462387/article/details/82432593?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

[锁机制（行级锁、表级锁）](https://blog.csdn.net/qq_34337272/article/details/80611486)

Memory：显示支持哈希索引(注：为非唯一哈希索引)

[索引结构](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/数据库索引.md)：

## 索引结构

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。**

**常见索引：**

1）B+Tree 索引、

B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树

B树：用作文件系统索引

B+树：用作数据库索引

**一棵 B 树必须满足以下条件：**

- 根结点至少有两个子女。
- 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
- 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
- 所有的叶子结点都位于同一层。
- 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

B树在插入和删除元素时，需要严格按照定义进行，必要时可以拆分节点/旋转以保证平衡。

![img](https:////upload-images.jianshu.io/upload_images/15042957-e6ceb261a201a956.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

平衡二叉树与B树对比图。可以看到，B 树的每个节点可以表示的信息更多，因此整个树更加“矮胖”，这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度。

因为 B 树的子树大小排序规则，因此在 B 树中查找数据时，一般需要这样：
(1). 从根节点开始，如果查找的数据比根节点小，就去左子树找，否则去右子树
(2). 和子树的多个关键字进行比较，找到它所处的范围，然后去范围对应的子树中继续查找
(3). 以此循环，直到找到或者到叶子节点还没找到为止

**一个m阶的B+树具有如下几个特征：**

- 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。（无论插入/删除多少元素，最大元素值都要出现在根节点中）

![img](https:////upload-images.jianshu.io/upload_images/15042957-0a63f7cc85b77c8a.png?imageMogr2/auto-orient/strip|imageView2/2/w/883)

B+树示例

B+树的所有非叶子节点，都只是提供 子树最大值 与 根节点到叶子节点的索引，不存储实际的数据，而B-树的所有非叶子节点，都存储了子树的索引和真实数据。因此，B+树相对B-树来说更加矮胖。此外，相同大小的磁盘页，可以存储更多的B+树节点，查询时可以减少B+树的查询次数。

> B+树与B-树的查询性能对比：
>
> 1. 单元素查询
>    @ B+树相比B-树，磁盘IO次数更少
>    @ B+树一直会查询到叶子节点才停止查询；而B-树查找到对应元素立刻停止查询，除非无对应元素才会查找到叶子节点。相对来说，B+树的查找更加稳定。
> 2. 范围查询
>    B-树依靠中序遍历来进行范围查询（由于B-树的特性，其中序遍历一定是递增序列），需要从叶子节点向根节点层层遍历；而B+树所有的数据都存储在叶子节点，而且通过链表连接起来，因此只需查找叶子节点即可得到一个范围的数据。
>
> **综上所述，B+树相对于B树来说优势在于：**
> (1). 单一节点存储更多的元素，使得查询的IO次数更少
> (2). 所有查询都要查找到叶子节点，查询性能稳定
> (3). 所有叶子节点形成有序链表，便于范围查询

> **B树和B+树的应用场景：**
> 1). B树主要应用于文件系统及部分数据库索引，如著名的非关系型数据库MongoDB
> 2). 大部分关系型数据库如mySQL，都使用B+树作为索引

> 若不考虑磁盘IO的读取时间，m阶B树的时间复杂度为O(log (m^n))



作者：cca1yy
链接：https://www.jianshu.com/p/d754482242f5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

为什么用B+树？https://blog.csdn.net/xlgen157387/article/details/79450295

问题：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？

答：一、从内存角度上说，数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。

二、从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

哈希索引、

*哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制：*

*无法用于排序与分组；*
*只支持精确查找，无法用于部分查找和范围查找。*
*InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”：*

*当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，*
*这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。*

3）全文索引、 

4）空间数据索引



### 数据库哪些情况下适合建索引，哪些情况下不适合建索引

**一、哪些情况下适合建索引**

　　1. 频繁作为where条件语句查询的字段

　　2. 关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等

　　3. 排序字段可以建立索引

　　4. 分组字段可以建立索引，因为分组的前提是排序

　　5. 统计字段可以建立索引，例如count(),max()

**二、哪些情况下不适合建索引**

　　1.频繁更新的字段不适合建立索引

　　2.where条件中用不到的字段不适合建立索引

　　3.表数据可以确定比较少的不需要建索引

　　4.数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值

  5. 参与列计算的列不适合建索引

     

## 一条SQL语句执行得很慢的原因有哪些？

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd



## 事务四大特性ACID

事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）

1. **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
3. **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



## 事务隔离级别

为了解决并发事务带来的问题：

脏读、不可重复读、幻读

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看

1.脏读

A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。例如常见的取款事务和转账事务： 


2.不可重复读

不可重复读是指A事务读取了B事务已经提交的更改数据。假如A在取款事务的过程中，B往该账户转账100，A两次读取的余额发生不一致。

3.幻读

A事务读取B事务提交的新增数据,会引发幻读问题。幻读一般发生在计算统计数据的事务中，例如银行系统在同一个事务中两次统计存款账户的总金额，在两次统计中，刚好新增了一个存款账户，存入了100，这时候两次统计的总金额不一致。 

注意：不可重复读和幻读的区别是：前者是指读到了已经提交的事务的更改数据（修改或删除），后者是指读到了其他已经提交事务的新增数据。对于这两种问题解决采用不同的办法，防止读到更改数据，只需对操作的数据添加行级锁，防止操作中的数据发生变化；二防止读到新增数据，往往需要添加表级锁，将整张表锁定，防止新增数据（oracle采用多版本数据的方式实现）。
————————————————
版权声明：本文为CSDN博主「wu_amber」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_34462387/article/details/82432593

## 锁机制

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。

- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

  *只有在你增删改查时匹配的条件字段带有索引时，innodb才会使用行级锁，在你增删改查时匹配的条件字段不带有索引时，innodb使用的将是表级锁。*



## 一条sql语句的执行过程

•MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。

•引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。

•SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎

•对于更新（增，删，改）等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit

[参考](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)

https://www.cnblogs.com/wupeixuan/p/11734501.html



## Binlog三种格式详细介绍

binlog日志有三种格式，分别为Statement,MiXED,以及ROW！



**1.Statement：每一条会修改数据的sql都会记录在binlog中。**

优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)

缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).

**2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。**

优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题

缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。

**3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog**,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。

## 慢查询问题

**慢SQL的系统表现**

首先，我们如何判别系统中遇到了SQL慢查询问题？个人认为慢SQL有如下三个特征：

**1，数据库CPU负载高。**一般是查询语句中有很多计算逻辑，导致数据库cpu负载。

**2，IO负载高导致服务器卡住。**这个一般和全表查询没索引有关系。

**3，查询语句正常，索引正常但是还是慢。**如果表面上索引正常，但是查询慢，需要看看是否索引没有生效。



**开启SQL慢查询的日志**

如果你的系统出现了上述情况，并且你不是用的阿里云的RDS这样的产品，那么下一步就需要打开Mysql的慢查询日志来进一步定位问题。MySQL 提供了慢查询日志，这个日志会记录所有执行时间超过 long_query_time（默认是10s）的 SQL 及相关的信息。

要开启日志，需要在 MySQL 的配置文件 my.cnf 的 [mysqld] 项下配置慢查询日志开启，如下所示：

[mysqld]slow_query_log=1

slow_query_log_file=/var/log/mysql/log-slow-queries.log

long_query_time=2

在实际项目中，由于生成的慢查询的日志可能会特别大，分析起来不是很

方便，所以Mysql官方也提供了**mysqldumpslow**这个工具，方便我们分析慢查询日志，感兴趣的同学可以自行到Mysql官方进行查阅。

SQL调优

有些SQL虽然出现在慢查询日志中，但未必是其本身的性能问题，可能是因为锁等待，服务器压力高等等。需要分析SQL语句真实的执行计划，而不是看重新执行一遍SQL时，花费了多少时间，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用Explain工具来逐步调优，了解 MySQL 在执行这条数据时的一些细节，比如是否进行了优化、是否使用了索引等等。基于 Explain 的返回结果我们就可以根据 MySQL 的执行细节进一步分析是否应该优化搜索、怎样优化索引。

关于索引的创建及优化原则，个人特别推荐美团点评技术团队的几点总结，讲得特别好，特地引用一下：

最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整；

=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式；

尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录；

索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。



**一点总结**

基于本文的思路，关于SQL慢查询的解决可以按照以下的步骤执行：

\1. 打开慢日志查询，确定是否有SQL语句占用了过多资源，如果是，在不改变业务原意的前提下，对insert、group by、order by、join等语句进行优化。

\2. 考虑调整MySQL的系统参数： innodb_buffer_pool_size、innodb_log_file_size、table_cache等。

\3. 确定是否是因为高并发引起行锁的超时问题。

\4. 如果数据量过大，需要考虑进一步的分库分表，可以参见之前的[文章1](https://link.jianshu.com/?t=http://mp.weixin.qq.com/s?__biz=MzI3OTUwMjM4MA==&mid=2247483828&idx=1&sn=2f08dd3681177f1e585ad1078f7bf37a&chksm=eb478af7dc3003e173c52358c1751e68f5f9abf35fbd16ff02769d0c3e9f82fe1f81d48b3a36&scene=21#wechat_redirect)和[文章2](https://link.jianshu.com/?t=http://mp.weixin.qq.com/s?__biz=MzI3OTUwMjM4MA==&mid=2247483658&idx=1&sn=eb57c337ae929c468cc72d8ca673fd73&chksm=eb478a49dc30035ff6c9580bebcd64f383fd56d9cbe7b80a9253cfdad52d941ba460e8dfc95e&scene=21#wechat_redirect)。

## MySql优化

### 数据库高性能优化

数据库命令规范

数据库基本设计规范

数据库字段设计规范

索引设计规范

数据库 SQL 开发规范

数据库操作行为规范

[资料](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL高性能优化规范建议.md)

### 索引优化

https://blog.csdn.net/Zhxin606a/article/details/89555600?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

<img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-30/53535419.jpg" alt="img" style="zoom: 200%;" />

https://www.nowcoder.com/discuss/150059?type=0&order=0&pos=8&page=0



# 常见问题

## **数据库基础知识**

1、为什么要使用数据库
2、什么是SQL？
3、什么是MySQL?
4、数据库三大范式是什么
5、mysql有关权限的表都有哪几个
6、MySQL的binlog有有几种录入格式？分别有什么区别？

## **数据类型**

### 1、mysql有哪些数据类型 

**数值类型**

MySQL支持所有标准SQL数值数据类型。

这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。

关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。

BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。

作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 byte                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

------

**日期和时间类型**

表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

TIMESTAMP类型有专有的自动更新特性，将在后面描述。

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038 结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |

------

**字符串类型**

字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

**注意**：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。

有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。



#### VARCHAR与CHAR区别

**一. varchar存储规则：**

4.0版本以下，varchar(20)，指的是20***\*字节\****，如果存放UTF8汉字时，只能存6个（每个汉字3字节） 
5.0版本以上，varchar(20)，指的是20***\*字符\****，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节 
Mysql4中最大也不过是20个字节,但是Mysql5根据编码不同,存储大小也不同。 

**二. varchar和char 的区别：**

**char是一种固定长度的类型，varchar则是一种可变长度的类型**，它们的区别是： char(M)类型的数据列里，每个值都占用M个字符，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）． 

CHAR类型，在存储数据时，MySQL会删除所有文末的空格，所以，即便你存储的是：'abc '，注意这个字符串末尾是有空格的，也会在存储时把这个空格删掉，这点需要注意。

由于CHAR是固定长度的，所以它的处理速度比VARCHAR快得多，但是其缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储。

**varchar的优点：**

- 变长的字符串类型，兼容性更好

**varchar的缺点：**

- 使用varchar可能会产生内存碎片
- varchar会额外需要1到2个字节存储长度信息
- update语句可能会导致页分裂

**char的优点：**

- 定长的字符串类型，减少内存碎片
- 处理速度快
- 无需额外的内存空间去存储长度信息

**char的缺点：**

- 会删除列末尾的空格信息

**varchar适用的场景：**

- 字符串列的最大长度比平均长度要大很多；
- 字符串列的更新很少时，因为没有或很少有内存碎片问题；
- 使用了UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储；

**char适用的场景：**

- 列的长度为定值时适合适用，比如：MD5密文数据

## **引擎**

1、MySQL存储引擎MyISAM与InnoDB区别
2、MyISAM索引与InnoDB索引的区别？
3、InnoDB引擎的4大特性
4、存储引擎选择 

## **索引**

1、什么是索引？
2、索引有哪些优缺点？
3、索引使用场景（重点）
4、索引有哪几种类型？
5、索引的数据结构（b树，hash）
6、索引的基本原理
7、索引算法有哪些？
8、索引设计的原则？
9、创建索引的原则（重中之重）
10、创建索引的三种方式，删除索引
11、创建索引时需要注意什么？
12、使用索引查询一定能提高查询的性能吗？为什么
13、百万级别或以上的数据如何删除
14、前缀索引
15、什么是最左前缀原则？什么是最左匹配原则
16、B树和B+树的区别
17、使用B树的好处
18、使用B+树的好处
19、Hash索引和B+树所有有什么区别或者说优劣呢?
20、数据库为什么使用B+树而不是B树
21、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，
22、什么是聚簇索引？何时使用聚簇索引与非聚簇索引
23、非聚簇索引一定会回表查询吗？
24、联合索引是什么？为什么需要注意联合索引中的顺序？ 

## **事务**

1、什么是数据库事务？
2、事物的四大特性(ACID)介绍一下?
3、什么是脏读？幻读？不可重复读？
4、什么是事务的隔离级别？MySQL的默认隔离级别是什么？ 

## **锁**

1、对MySQL的锁了解吗
2、隔离级别与锁的关系
3、按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法
4、从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了
5、MySQL中InnoDB引擎的行锁是怎么实现的？
6、InnoDB存储引擎的锁的算法有三种
7、什么是死锁？怎么解决？
8、数据库的乐观锁和悲观锁是什么？怎么实现的？ 

## **视图**

1、为什么要使用视图？什么是视图？
2、视图有哪些特点？
3、视图的使用场景有哪些？
4、视图的优点
5、视图的缺点
6、什么是游标？ 

## **存储过程与函数**

1、什么是存储过程？有哪些优缺点？ 

## **触发器**

1、什么是触发器？触发器的使用场景有哪些？
2、MySQL中都有哪些触发器？ 

## **常用SQL语句**

1、SQL语句主要分为哪几类
2、超键、候选键、主键、外键分别是什么？
3、SQL 约束有哪几种？
4、六种关联查询
5、什么是子查询
6、子查询的三种情况
7、mysql中 in 和 exists 区别
8、varchar与char的区别
9、varchar(50)中50的涵义
10、int(20)中20的涵义
11、mysql为什么这么设计
12、mysql中int(10)和char(10)以及varchar(10)的区别
13、FLOAT和DOUBLE的区别是什么？
14、drop、delete与truncate的区别
15、UNION与UNION ALL的区别？ 

## **SQL优化**

1、如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？
2、SQL的生命周期？
3、大表数据查询，怎么优化
4、超大分页怎么处理？
5、mysql 分页
6、慢查询日志
7、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？
8、为什么要尽量设定一个主键？
9、主键使用自增ID还是UUID？
10、字段为什么要求定义为not null？
11、如果要存储用户的密码散列，应该使用什么字段进行存储？
12、优化查询过程中的数据访问
13、优化长难的查询语句
14、优化特定类型的查询语句
15、优化关联查询
16、优化子查询
17、优化LIMIT分页
18、优化UNION查询
19、优化WHERE子句 

## **数据库优化**

1、为什么要优化
2、数据库结构优化
3、MySQL数据库cpu飙升到500%的话他怎么处理？
4、大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？
垂直分表
适用场景
缺点
水平分表：
适用场景
水平切分的缺点
5、MySQL的复制原理以及流程
6、读写分离有哪些解决方案？
7、备份计划，mysqldump以及xtranbackup的实现原理
8、数据表损坏的修复方式有哪些？