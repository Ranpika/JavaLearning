## CPU上下文切换与系统调用

**什么是上下文**

- CPU寄存器，是CPU内置的容量小、但速度极快的内存，
- 程序计数器，则是用来存储CPU正在执行的指令的位置，或者即将执行的下一条指令的位置。
- 他们都是CPU在运行任何任务前，必须依赖的环境

**什么是上下文切换**

- 有时也称做进程切换或任务切换，是指CPU 从一个进程或线程切换到另一个进程或线程
  - 先把前一个任务的CPU上下文(也就是CPU寄存器和程序计数器)保存起来，然后加载新任务的上下文，到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

**系统调用**

- 可以实现从用户态到内核态的转变

**系统调用的过程有没有发生CPU上下文切换**

- 有，且发生了两次
- 需要先保存CPU寄存器里原来用户态的指令位置，接着，为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。
- 而系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程，所以一次系统调用的过程，其实是发生了两次CPU上下文切换。

**系统调用和进程上下文切换的区别**

- 进程上下文切换，是指从一个进程切换到另一个进程运行。
- 而系统调用过程中一直是同一个进程在运行。



## 进程与线程

线程与进程最大的区别在与，**线程是调度的基本单位，而进程则是资源拥有的基本单位**。说白了，所谓内核中的任务调用，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于现场和进程，我们可以这么理解：

- 当进程只有一个线程时，可以认为进程就等于线程。
- 当进程拥有多个线程时，这些线程会共享相同的**虚拟内存**和**全局变量**等资源。这些资源在上下文切换时是不需要修改的。
- 另外，线程也有自己的私有数据，比如**栈**和**寄存器**等，这些在上下文切换时也是需要保存的。

**线程的上下文切换其实就可以分为两种情况：**
第一种，前后俩个线程属于不同进程，此时，由于资源不共享，所以切换过程就跟进程上下文切换是一样的。
第二种，前后两个线程属于同一个进程，此时，应为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据。

## 线程的生命周期

![线程状态概述](https://img-blog.csdnimg.cn/20200317214332662.png)

![线程转换图](https://img-blog.csdnimg.cn/20200317215520951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2NzAxNQ==,size_16,color_FFFFFF,t_70)

## 进程的状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。

- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。

- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。

- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。

- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

  ![process-state](https://camo.githubusercontent.com/4d7a4d9f7973b278bc19c388b40cab2bd3222a6e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f64333832303235393330313262343537646562626364373439393463363239322e706e67)

## 死锁

### 什么是死锁：

死锁是指两个或两个以上的进程在执行过程中，因资源争夺而造成的一种相互等待的现象，若不做处理，它们将一直等待下去。例如：进程A和进程B，进程A运行在某一时刻需要进程B所持有的资源，进程B此时运行也需要A进程所持有的资源，因此进程A和进程B都等待对方释放资源，这就产生了死锁。  

### 死锁产生条件：

![img](https://images0.cnblogs.com/blog/627141/201410/031205406596624.jpg)

### 避免死锁：

![img](https://images0.cnblogs.com/blog/627141/201410/031209304876938.png)

1. 正确的顺序获得锁

如果必须获取多个锁，我们就要考虑不同线程获取锁的顺序。

上面的例子出现**死锁的根本原因就是获取所的顺序是乱序**的，超乎我们控制的。上面例子最理想的情况就是把业务逻辑抽离出来，**把获取锁的代码放在一个公共的方法里面，让这两个线程获取锁都是从我的公共的方法里面获取。**

2. 超时放弃

当线程获取锁超时了则放弃，这样就避免了出现死锁获取的情况。当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，**然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法**，该方法可以按照固定时长等待锁，**因此线程可以在获取锁超时以后**，**主动释放之前已经获得的所有的锁**。通过这种方式，也可以很有效地避免死锁。

**银行家算法**

```
1、操作系统按照银行家指定的规则为进程分配资源，当进程首次申请资源时，需要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请资源分配资源，否则就推迟分配；
2、当进程在执行中继续申请资源时，先测试该进程本次申请的资源数，是否超过了该资源剩余的总量，若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。
```

### 死锁的解除

如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：
1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。
2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。
    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。
    b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该**采用最优策略来选择一个“代价最小”的进程来解除死锁状态**。一般根据如下几个方面来决定终止哪个进程：
    进程的优先级
    进程已运行时间以及运行完成还需要的时间
    进程已占用系统资源
    进程运行完成还需要的资源
    终止进程数目
    进程是交互还是批处理



## 静态库和动态库的区别

\1. 静态函数库 

​    这类库的名字一般是libxxx.a；利用静态函数库编译成的文件比较大，因为整个 函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。

\2. 动态函数库 

​    这类库的名字一般是libxxx.so;相对于静态函数库，动态函数库在编译的时候 并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。 
linux系统有几个重要的目录存放相应的函数库，如/lib /usr/lib。